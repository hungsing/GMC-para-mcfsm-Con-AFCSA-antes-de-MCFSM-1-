%!TEX root = ./main.tex
\chapter{Introducción}
La teoría de autómatas es el estudio de artefactos abstractos de computación o ``máquinas''. Antes de la existencia de computadoras, Alan Turing estudió una máquina abstracta que tenía todas las capacidades de las computadoras de hoy, en el sentido de tener la capacidad de computar \cite{turing:plms-s2-42_1,turing:plms-s2-43_1}. \cnote{No tengo claro qué quiere decir esta oración.}El objetivo de Turing era describir con precisión el límite entre lo que una computadora podía hacer y lo que no. Estas conclusiones no aplican a sus máquinas abstractas sino a las máquinas reales de hoy en día \cite{ullman}.

Entre los 40s y los 50s se estudiaron máquinas más sencillas, que hoy denominamos `autómatas finitos'. Estos autómatas, originalmente pensados para modelar el funcionamiento del cerebro, resultaron ser muy útiles para una variedad de propósitos. Noam Chomsky inició el estudio de gramáticas formales \cite{chomsky:iretit-2_3}. Si bien no eran estrictamente máquinas, estas gramáticas tienen una relación muy cercana con los autómatas abstractos y hoy en día sirven como la base de algunos componentes de software importantes, incluyendo partes de compiladores.

Todos estos desarrollos teóricos tienen relación directa con lo que se estudia en ciencias de la computación. Algunos de estos conceptos, como autómatas finitos y ciertas gramáticas formales, se usan en el diseño y la construcción de distintos tipos de artefactos de software.

Los autómatas consisten de estados (representados gráficamente con círculos) y transiciones (representadas con flechas). Cuando el autómata ve el símbolo de entrada, ejecuta la transición a otro estado, de acuerdo con su función de transición que toma el estado actual y el símbolo reciente como parámetros de entrada. Un autómata finito puede tener uno o más estados finales o \emph{accepting states}. Estos estados representan el fin de la ejecución del proceso modelado por el autómata.\\

La tendencia hacia los sistemas distribuidos genera la necesidad de mecanismos de comunicación más complejos. Para manejar esta complejidad se han introducido lenguajes de especificación y métodos formales de análisis que permiten asegurar ciertas propiedades de dichos mecanismos como por ejemplo, las \emph{Communicating Finite State Machines} \cite{brand:jacm-30_2}, los \emph{Global Graphs} \cite{castagna:lmcs-8_1}, los \emph{Session types} en su gran diversidad de variantes \cite{honda:esop98,honda:popl08} y los \emph{Interface automata} \cite{dealfaro:esec-fse-01}. Tomando esto en consideración, los autómatas finitos resultan útiles como lenguaje primitivo de modelado, subyacente en muchos de los formalismos mencionados anteriormente, que permite representar algunos de estos aspectos de dichos sistemas.

Service oriented computing (SOC) es un paradigma de computación distribuida que cambió el modo en que los sistemas de software son concebidos. El corazón del paradigma son servicios que proveen elementos computacionales autónomos, independientes de la plataforma y que se ejecutan sobre una infraestructura de cómputo y comunicación existente. Estos pueden ser descritos, publicados, descubiertos y programados usando protocolos estándar para construir redes de aplicaciones que colaboran entre sí, incluso distribuidas dentro de distintas fronteras organizacionales, con la misión de, colectivamente, alcanzar un objetivo de negocios. Uno de los elementos centrales de este paradigma es que dichos elementos computacionales son procurados en tiempo de ejecución y bajo demanda; una demanda, resulta local a cada ejecución, lo que implica que no todos los servicios necesarios son al mismo tiempo y algunos, puede que ni siquiera lo sean.

Esta mirada sobre cómo un sistema de software evoluciona reconfigurándose en tiempo de ejecución pone de relieve la necesidad de contar con un lenguaje de descripción que posibilite un enfoque para la composición que sea parcial, y que el resultado de dicha composición resulte una descripción legítima de una componente; una característica que la gran mayoría de los lenguaje utilizados en la descripción de sistemas distribuidos no posee. Volveremos sobre esto en la Sec.~\ref{trabajo-relacionado} donde discutiremos otros lenguajes formales relacionados, que hemos mencionado más arriba, al final de la presente.\\

En este trabajo buscaremos definir un lenguaje formal de modelado de componentes de software con el objeto de satisfacer las necesidades mencionadas anteriormente. Este lenguaje debe satisfacer las siguientes propiedades:
\begin{inparaenum}[1.]
\item debe posibilitar la convivencia de elementos computacionales internos de una componente (transiciones que expresan cambios locales de estado) con su interfaz de comunicación (transiciones que expresan envío o recepción de mensajes),
\item debe poseer un mecanismo claro de composición que no requiera que todos los participantes, y
\item debe tener semántica de comunicación asincrónica, compatible con la semántica de los lenguajes formales conocidos como los mencionados anteriormente).
\end{inparaenum}

Para satisfacer estos objetivos definiremos una clase de autómatas finitos, a la que llamaremos \emph{Autómatas Finitos de Comunicación Asincrónica} (AFCA), que cuentan con transiciones internas (denotando cambios locales de estado) y transiciones de comunicación sobre canales de comunicación (que expresan la comunicación con otras componentes), adicionalmente, estos autómatas pueden ser compuestos internalizando la comunicación a través de la creación de buffers dedicados que permiten reemplazar los canales de comunicación. Adaptaremos el lenguaje de las Communicating Finite State Machines, a las llamaremos \emph{multichannel Communicating Finite State Machines} (mCFSM), con el objeto de que sean capaces de reflejar la interfaz de comunicación de estos autómatas. Por último, probaremos la equivalencia entre la semántica de la composición de una familia de AFCAs y la del \emph{communicating system} obtenido a partir de la familia de CFSM correspondientes a cada uno de dichos AFCAs (ver Fig.~\ref{fig:equivalencia}).\\

En la siguiente sección presentamos brevemente distintos trabajos relacionados y como esos modelos no cumplen del todo con lo que queríamos modelar. El resto de esta tesis se divide en cuatro capítulos. Primero en el capítulo~\ref{preliminares} describimos las CFSM como lenguaje y la noción de Generalized Multiparty Compatibility (GMC, \cite{lange:popl15}) como condición suficiente para que un conjunto de CFSMs formen un communicating system seguro. En el capítulo~\ref{AFCA} definimos los AFCA, su composición, y la proyección de su interfaz de comunicación. También definimos mCFSM como extensión de CFSM y proyección de la interfaz de comunicación de un AFCA, y adaptamos la propiedad de GMC para este nuevo modelo. En el capítulo~\ref{resultados} exploramos la equivalencia de la semántica de un conjunto de AFCA y el communicating system resultante de su mCFSM proyectadas, y demostramos la validez de esta propiedad. Por último, en el capítulo~\ref{conclusiones} cerramos este trabajo con las conclusiones resultantes y algunas ideas para trabajo a futuro.


\section{Trabajo relacionado}
\label{trabajo-relacionado}

\begin{itemize}
\item \emph{Communicating Finite State Machines} \cite{brand:jacm-30_2}:  Las CFSM son un modelo para protocolos de comunicación, basado en máquinas de estado finitas que representan procesos que se comunican entre vía el intercambio asincrónico de mensajes a través de canales FIFO. Las mCFSM son una versión extendida de dicho modelo con múltiples canales entre cada par de participantes y la interfaz de comunicación de los AFCA se proyecta como una mCFSM.
\item \emph{Session types} \cite{honda:esop98,honda:popl08}: Session Types es un cálculo tipado para procesos móbiles que introduce una nueva noción de tipos en la que las interacciones que incluyen múltiples participante se abstraen directamente como un escenario global. Un global type cumple el rol de un acuerdo compartido entre pares que se comunican y es la base de type checking eficiente a través de su proyección sobre participantes individuales. Las propiedades fundamentales de la disciplina de session types como seguridad communication safety, progress y session fidelity son establecidas para interacciones asincrónicas de n participantes. Esta noción de acuerdos entre participantes formalizada a través de los global types permite modelar interacciones entre participantes de una comunicación con garantía de 
\item \emph{Global Graphs} \cite{castagna:lmcs-8_1}: 
 y 
\item \emph{Interface automata} \cite{dealfaro:esec-fse-01}
\end{itemize}

Discutir el trabajo que encontramos.