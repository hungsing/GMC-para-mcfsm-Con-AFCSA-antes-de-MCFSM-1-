%!TEX root = ./main.tex
\chapter{Introducción}
La tendencia hacia los sistemas distribuidos genera la necesidad de mecanismos de comunicación más complejos. Para manejar esta complejidad se han introducido lenguajes de especificación y métodos formales de análisis que permiten asegurar ciertas propiedades de dichos mecanismos como por ejemplo, las \emph{Communicating Finite State Machines} \cite{brand:jacm-30_2}, los \emph{Global Graphs} \cite{castagna:lmcs-8_1}, los \emph{Session types} en su gran diversidad de variantes \cite{honda:esop98,honda:popl08} y los \emph{Interface automata} \cite{dealfaro:esec-fse-01}. Tomando esto en consideración, los autómatas finitos \cite[Def.~2.2.1]{hopcroft01} resultan útiles como lenguaje primitivo de modelado, subyacente en muchos de los formalismos mencionados anteriormente, que permite representar algunos de estos aspectos de dichos sistemas.

Service oriented computing (SOC) es un paradigma de computación distribuida que cambió el modo en que los sistemas de software son concebidos. El corazón del paradigma son servicios que proveen elementos computacionales autónomos, independientes de la plataforma y que se ejecutan sobre una infraestructura de cómputo y comunicación existente. Estos pueden ser descritos, publicados, descubiertos y programados usando protocolos estándar para construir redes de aplicaciones que colaboran entre sí, incluso distribuidas dentro de distintas fronteras organizacionales, con la misión de, colectivamente, alcanzar un objetivo de negocios. Uno de los elementos centrales de este paradigma es que dichos elementos computacionales son procurados en tiempo de ejecución y bajo demanda; una demanda, resulta local a cada ejecución, lo que implica que no todos los servicios necesarios son al mismo tiempo y algunos, puede que ni siquiera lo sean.

Esta mirada sobre cómo un sistema de software evoluciona reconfigurándose en tiempo de ejecución pone de relieve la necesidad de contar con un lenguaje de descripción que posibilite un enfoque para la composición que sea parcial, y que el resultado de dicha composición resulte una descripción legítima de una componente; una característica que la gran mayoría de los lenguaje utilizados en la descripción de sistemas distribuidos no posee. Volveremos sobre esto en la Sec.~\ref{trabajo-relacionado} donde discutiremos otros lenguajes formales relacionados, que hemos mencionado más arriba, al final de la presente.\\

En este trabajo buscaremos definir un lenguaje formal de modelado de componentes de software con el objeto de satisfacer las necesidades mencionadas anteriormente. Este lenguaje debe satisfacer las siguientes propiedades:
\begin{inparaenum}[1.]
\item debe posibilitar la convivencia de elementos computacionales internos de una componente (transiciones que expresan cambios locales de estado) con su interfaz de comunicación (transiciones que expresan envío o recepción de mensajes),
\item debe poseer un mecanismo claro de composición que no requiera que todos los participantes, y
\item debe tener semántica de comunicación asincrónica, compatible con la semántica de los lenguajes formales conocidos como los mencionados anteriormente).
\end{inparaenum}

Para satisfacer estos objetivos definiremos una clase de autómatas finitos, a la que llamaremos \emph{Autómatas Finitos de Comunicación Asincrónica} (AFCA), que cuentan con transiciones internas (denotando cambios locales de estado) y transiciones de comunicación sobre canales de comunicación (que expresan la comunicación con otras componentes), adicionalmente, estos autómatas pueden ser compuestos internalizando la comunicación a través de la creación de buffers dedicados que permiten reemplazar los canales de comunicación. Adaptaremos el lenguaje de las Communicating Finite State Machines, a las llamaremos \emph{multichannel Communicating Finite State Machines} (mCFSM), con el objeto de que sean capaces de reflejar la interfaz de comunicación de estos autómatas. Por último, probaremos la equivalencia entre la semántica de la composición de una familia de AFCAs y la del \emph{communicating system} obtenido a partir de la familia de CFSM correspondientes a cada uno de dichos AFCAs (ver Fig.~\ref{fig:preservacion}).\\

En la siguiente sección presentamos brevemente distintos trabajos relacionados y como esos modelos no cumplen del todo con lo que queríamos modelar. El resto de esta tesis se divide en cuatro capítulos. Primero en el capítulo~\ref{preliminares} describimos las CFSM como lenguaje y la noción de Generalized Multiparty Compatibility (GMC, \cite{lange:popl15}) como condición suficiente para que un conjunto de CFSMs formen un communicating system seguro. En el capítulo~\ref{AFCA} definimos los AFCA, su composición, y la proyección de su interfaz de comunicación. También definimos mCFSM como extensión de CFSM y proyección de la interfaz de comunicación de un AFCA, y adaptamos la propiedad de GMC para este nuevo modelo. En el capítulo~\ref{resultados} exploramos la equivalencia de la semántica de un conjunto de AFCA y el communicating system resultante de su mCFSM proyectadas, y demostramos la validez de esta propiedad. Por último, en el capítulo~\ref{conclusiones} cerramos este trabajo con las conclusiones resultantes y algunas ideas para trabajo a futuro.


\section*{Trabajo relacionado}
\label{trabajo-relacionado}
Como se ha dicho anteriormente, la propuesta de la presente tesis es la presentación de un lenguaje que permita describir componentes de un sistema distribuido, con las siguientes particularidades: 
\begin{itemize}
\item debe posibilitar la convivencia de acciones internas, vinculadas al cómputo que realiza localmente la componente, junto con primitivas de comunicación utilizadas para interactuar con las restantes componentes del sistema, y
\item se espera que posea un mecanismo de composición parcial, en relación al conjunto esperado de participantes.
\end{itemize}

Existe una gran variedad de lenguajes que permiten la formalización de la comunicación entre componentes de un sistema distribuido. Algunos ejemplos de interés en este campo son:

\emph{Communicating Finite State Machines} \cite{brand:jacm-30_2}: Las CFSM son un lenguaje de modelado de agentes que se comunican a través del envío y recepción de mensajes. Están basadas en máquinas de estado finitas y su rationale es que los estados del autómata representan los estados de la componente mientras que las aristas representan los eventos de comunicación. Estos eventos pueden ser de envío o recepción de mensajes, hacia o desde otro participante. Su semántica de comunicación es asincrónica interpretando a los envíos y recepciones como epósito o consumo de dichos mensajes sobre colas FIFO específicamente reservadas para cada par de participantes.\\

\cnote{Esto es parte de nuestra contribución, no debe estar acá sino en la sección donde se presentan. Quzás ya lo está.}
\begin{quotation}
Las mCFSM son una versión extendida de dicho modelo con múltiples canales entre cada par de participantes y la interfaz de comunicación de los AFCA se proyecta como una mCFSM. A su vez los AFCA surgen de la necesidad de poder representar en un mismo formalismo todo el comportamiento de cada componente, tanto el interno como el de comunicación externa.
\end{quotation}

\emph{Session types} \cite{honda:esop98,honda:popl08}: los tipos sesión son un cálculo que introduce una nueva noción de tipos para procesos móbiles en la que las interacciones, que incluyen múltiples participantes, se abstraen directamente como un escenario global. Un global type cumple el rol de un acuerdo compartido entre pares que se comunican y es la base de \emph{type checking} eficiente a través de su proyección sobre participantes individuales. Algunas propiedades fundamentales de un conjunto bien tipado de participantes son \emph{communication safety}, \emph{progress} y \emph{session fidelity}. Esta noción de acuerdos entre participantes, formalizada a través de los global types, permite modelar las interacciones entre participantes de una comunicación y demostrar las propiedades mencionadas anteriormente.\\

\emph{Global Graphs} \cite{castagna:lmcs-8_1}: los \emph{Global Graphs} son una superclase de los \emph{Generalized Global Types} de \cite{denielou:esop12} que a su vez son una versión de los \emph{multi-party session global types}. Esta versión de \emph{global types} presenta un lenguaje simplificado equipado con semántica basada en trazas de un autómata finito. Los estados de dicho autómata representan estados del sistema distribuido conformado por los participantes de la comunicación y las aristas indican eventos de comunicación (en realidad solo prescriben el envío del mensaje puesto que la comunicación es asincrónica) de la forma ``el participante {\tt a} envía el mensaje {\tt m} al participante {\tt b}''.\\

\cnote{Esto tiene que ir cuando se presenta el tema como compliance entre la visión global de la comunicación, un global graph, y las locales, un conjunto de CFSMs.}
\begin{quotation}
La noción de GMC originalmente surge en \cite{lange:popl15} como condición para que un communicating system compuesto de un conjunto de CFSMs fuese seguro para poder construir un Global Graph que modele la comunicación del sistema.  
\end{quotation}

En el caso de todo ellos, el objetivo central es el de caracterizar formalmente la comunicación entre un conjunto de componentes de forma que se posible garantizar que esta se lleva a cabo en forma correcta. Usualmente se entiendo como correcto la satisfacción de tres condiciones esenciales:
\begin{inparaenum}[1)]
\item {\bf ausencia de deadlock}: si un participante espera un mensaje determinado de un participante, este será recibido en algún momento, 
\item {\bf ausencia de recepción no especificada}: cuando un participante espera un mensaje determinado no puede ocurrir que este reciba un mensaje diferente, y
\item {\bf ausencia de mensajes huérfanos}: todo mensaje que es enviado, eventualmente es recibido por su destinatario.
\end{inparaenum}

Por otro lado, la propia definición de \emph{communicating systems} en cualquiera de estos lenguajes impone el conocimiento de todos los participantes que formarán parte de la comunicación, sea porque son parte de la descripción global de esta, o porque es necesaria la vista local de todos ellos. A continuación resumimos algunos lenguajes que comparten la motivación con esta tesis, la provisión de un lenguaje que permite la descripción de sistemas abiertos en los que no todos los participantes son conocidos proveyendo, entre otras cosas, un mecanismo de composición parcial de componentes.\\

\emph{Interface automata} \cite{dealfaro:esec-fse-01}: Es un lenguaje basado en autómatas que captura el comportamiento asumido respecto al orden en el que los métodos de una componente son invocados, y el orden en el que se invocan métodos externos. Similar a las CFSMs esto permite modelar la interacción entre distintas componentes de un sistema y validar el correcto comportamiento\cnote{Decir cuál es el criterio de corrección.}. A diferencia de las CFSMs estos autómatas modelan no solo comportamiento de la comunicación (a través de acciones de input y output) sino también internas, y pueden componerse dadas ciertas condiciones de compatibilidad. La desventaja respecto a las CFSMs es que las interacciones entre estos autómatas tienen semántica sincrónica, lo que se hace explícito en la composición de dos autómatas donde una acción de salida de un autómata que coincide con la de entrada de otro se transforman en una única acción.\\

\emph{Global Types for Open Systems} \cite{barbanera:eptcs279}: Los formalismos basados en Global Types permiten describir el comportamiento general de un sistema distribuido y al mismo tiempo formalizar ciertas propiedades de seguridad para la comunicación entre las componentes del sistema. La visión centralizada de los \emph{global types} es adecuada para describir sistemas cerrados, es decir, sistemas en los que todas las componentes que forman parte de él son conocidas. Esto impide que un sistema descrito en base a \emph{global types} se pueda ver como un módulo independiente que puede conectarse a otros sistemas. De la necesidad de resolver esta problemática surgen los \emph{global types abiertos}. En este enfoque un \emph{global type abierto}, denominado \emph{global type with interface roles} (GTIR), denota un número de sistemas abiertos de CFSMs donde ciertos participantes (roles en este contexto) son identificados como interfaces en vez de como participantes propiamente dichos. Para lo cual se introduce una sintaxis paramétrica que, dado un formalismo basado en \emph{global types}, extiende su sintaxis, permitiéndole identificar algunos roles como \emph{interface roles} y definir una composición de \emph{global types abiertos}, interpretados semánticamente como sistemas de CFSMs. Esta sintaxis no depende de un formalismo particular, sino en general mientras las componentes individuales o \emph{end points} puedan ser interpretados como CFSMs. Esta nueva sintaxis además permite asegurar la preservación de las condiciones de seguridad mencionadas anteriormente bajo la composición, siempre que se satisfagan ciertas condiciones.

Los GTIRs, al igual que otros formalismos anteriormente mencionados, se enfocan únicamente en el aspecto comunicacional, es decir en la interacción entre componentes, dejando de lado el comportamiento interno (i.e. los elementos computacionales) de la componente.\\

\emph{Choreography automata} \cite{barbanera:coordination20}\cnote{Escribir}

