%!TEX root = ./main.tex
\section{Introducción}
La teoría de autómatas es el estudio de artefactos abstractos de computación o "máquinas". Antes de la existencia de computadoras Alan Turing estudió una máquina abstracta que tenía todas las capacidades que las computadoras de hoy en el aspecto de qué podían computar. El objetivo de Turing era describir con precisión el límite entre lo que una computadora podía hacer y lo que no. Estas conclusiones no aplican a sus máquinas de Turing abstractas sino a las máquinas reales de hoy en día.

Entre los 40s y los 50s se estudiaron máquinas más sencillas, que hoy denominamos "autómatas finitos". Estos autómatas, originalmente pensados para modelar el funcionamiento del cebebro, resultaron ser muy útiles para una variedad de propósitos. Noam Chomsky inició el estudio de gramáticas formales. Si bien no eran estrictamente máquinas, estas gramáticas tienen una realción muy cercana con los autómatas abstractos y hoy en día sirven como la base de algunos componentes de software importantes, incluyendo partes de compiladores.

Todos estos desarrollos teóricos tienen relación directa con lo que se estudia en ciencias de la computación. Algunos de estos conceptos, como autómatas finitos y ciertas gramáticas formales, se usan en el diseño y la construcción de distintos tipos de software.

Los autómatas consisten de estados (representados gráficamente con círculos) y transiciones (representadas con flechas). Cuando el autómata ve el símbolo de entrada, ejecuta la transición a otro estado, de acuerdo con su función de transición que toma el estado actual y el símbolo reciente como parámetros de entrada. Por lo general cuando nos referimos a autómatas finitos, hablamos del conjunto de estados distintos que lo componen. Un autómata finito puede tener uno o más estados finales o accepting states. Estos estados representan el fin de la ejecución del proceso modelado por el autómata.

Los aútomatas finitos son un modelo útil para una gran variedad de software y hardware. Entre las más importantes encontramos: software para diseñar y chequear el comportamiento de circuitos digitales; el analizador lexicográfico de un compilador; software para leer textos y encontrar patrones; y, lo más relevante a este trabajo, software para verificar sistemas de todo tipo que tienen un número finito de estados distintos, como protocolos de comunicación.

La tendencia hacia los sistemas distribuidos y las redes a medida que va creciendo genera la necesidad de protocolos de comunicación más complejos. Para manejar esta complejidad se han ido introduciendo métodos formales de especificación y análisis. Dentro de estos métodos, los autómatas finitos resultan una familia de modelos apta para representar el funcionamiento de ciertos sistemas distribuidos.

Service oriented computing (SOC) es un paradigma interdisciplinario para computación distribuida. SOC cambió el modo en que las aplicaciones de software se diseñan, envían y consumen. El corazón del paradigma son servicios que proveen elementos computacionales autónomos, independientes de plataforma. Estos pueden ser descritos, publicados, descubiertos y programados usando protocolos estándar para construir redes de aplicaciones que colaboran entre sí, distribuidas dentro de distintos fronteras organizacionales.

% Service-oriented computing is an emerging cross-disciplinary paradigm for distributed computing, which is changing the way software applications are designed, delivered and consumed. At the heart of service-oriented computing are services that provide autonomous, platform-independent, computational elements that can be described, published, discovered, orchestrated and programmed using standard protocols to build networks of collaborating applications distributed within and across organizational boundaries.
 