%!TEX root = ./main.tex
\newpage
\chapter{Conclusiones, trabajo relacionado y Trabajo futuro} 
\label{conclusiones}

En esta sección resumimos las contribuciones de esta tesis junto con conclusiones, trabajos relacionados que nos parecen de relevancia y posibles futuras líneas de investigación.


\section{Conclusiones} 

El objetivo de esta tesis era el estudio y posible extensión de los modelos formales para servicios, dado que consideramos que son necesarios para la implementación de SOC en toda su capacidad. Partiendo del ideal del paradigma SOC, es decir, un contexto que permita la reconfiguración dinámica de un artefacto de software a partir de posibilitar el binding en tiempo de ejecución, el objetivo principal fue crear un formalismo que soporte binding parcial. Con este objetivo en mente desarrollamos los AFCA que permiten internalizar el envío y la recepción de mensajes como comportamiento interno de una componente resultante de la composición. Dicho mecanismo de composición, además, preserva la comunicación externa de las componentes involucradas.

Para expresar la interfaz externa de comunicación de ese tipo de autómatas propusimos las mCFSMs, una extensión de las CFSMs con múltiples canales entre cada par de participantes. esto facilita la unificación de las interacciones de dos componente a ser compuestas, con una tercera. Como método para garantizar que los distintos participantes puedan interoperar en forma segura extendimos la noción de GMC para mCFSMs. Por último pudimos demostrar la equivalencia entre el comportamiento de la composición de un conjunto de AFCA y el de sus respectivas mCFSMs.\\
Todos estos elementos proporcionan los fundamentos de un lenguaje formal que provee un mecanismo de composición parcial, en el sentido de lo explicado en la Sec.~\ref{afca-compo-parcial}, y los vincula con resultados conocidos del campo de los sistemas distribuidos que permiten garantizar una interoperación libre de errores.

\section{Trabajo relacionado}
\label{trabajo-relacionado}
Como se ha dicho anteriormente, la propuesta de la presente tesis es la presentación de un lenguaje que permita describir componentes de un sistema distribuido, con las siguientes particularidades: 
\begin{itemize}
\item debe posibilitar la convivencia de acciones internas, vinculadas al cómputo que realiza localmente la componente, junto con primitivas de comunicación utilizadas para interactuar con las restantes componentes del sistema, y
\item se espera que posea un mecanismo de composición parcial, en relación al conjunto esperado de participantes.
\end{itemize}

Existe una gran variedad de lenguajes que permiten la formalización de la comunicación entre componentes de un sistema distribuido. Algunos ejemplos de interés en este campo son:

% \emph{Communicating Finite State Machines} \cite{brand:jacm-30_2}: las CFSM son un lenguaje de modelado de agentes que se comunican a través del envío y recepción de mensajes. Están basadas en máquinas de estado finitas y su rationale es que los estados del autómata representan los estados de la componente mientras que las aristas representan los eventos de comunicación. Estos eventos pueden ser de envío de mensajes hacia, o recepción de mensajes de, otro participante. Su semántica de comunicación es asincrónica interpretando a los envíos y recepciones como depósito o consumo de dichos mensajes sobre colas FIFO específicamente reservadas para cada par de participantes. \\

\emph{Session types} \cite{honda:esop98,honda:popl08}: los session types son un cálculo que introduce una nueva noción de tipos para procesos móviles en la que las interacciones, que incluyen múltiples participantes, se abstraen directamente como un escenario global. Un global type cumple el rol de un acuerdo compartido entre pares que se comunican y es la base de \emph{type checking} eficiente a través de su proyección sobre participantes individuales. Algunas propiedades fundamentales de un conjunto bien tipado de participantes son \emph{communication safety}, \emph{progress} y \emph{session fidelity}. Esta noción de acuerdos entre participantes, formalizada a través de los global types, permite modelar las interacciones entre participantes de una comunicación y demostrar las propiedades mencionadas anteriormente.\\

\emph{Global Graphs} \cite{castagna:lmcs-8_1}: los \emph{Global Graphs} son una superclase de los \emph{Generalized Global Types} de \cite{denielou:esop12} que a su vez son una versión de los \emph{multi-party session global types}. Esta versión de \emph{global types} presenta un lenguaje simplificado equipado con semántica basada en trazas de un autómata finito. Los estados de dicho autómata representan estados del sistema distribuido conformado por los participantes de la comunicación y las aristas indican eventos de comunicación (en realidad solo prescriben el envío del mensaje puesto que la comunicación es asincrónica) de la forma ``el participante {\tt a} envía el mensaje {\tt m} al participante {\tt b}''.\\

En el caso de todo ellos, el objetivo central es el de caracterizar formalmente la comunicación entre un conjunto de componentes de forma que se posible garantizar que esta se lleva a cabo en forma correcta. Usualmente se entiendo como correcto la satisfacción de tres condiciones esenciales:
\begin{inparaenum}[1)]
\item {\bf ausencia de deadlock}: si un participante espera un mensaje determinado de otro, este será recibido en algún momento, 
\item {\bf ausencia de recepción no especificada}: cuando un participante espera un mensaje determinado no puede ocurrir que este reciba un mensaje diferente, y
\item {\bf ausencia de mensajes huérfanos}: todo mensaje que es enviado, eventualmente es recibido por su destinatario.
\end{inparaenum}

Por otro lado, la propia definición de \emph{communicating systems} en cualquiera de estos lenguajes impone el conocimiento de todos los participantes que formarán parte de la comunicación, sea porque son parte de la descripción global de esta, o porque es necesaria la vista local de todos ellos. A continuación resumimos algunos lenguajes que comparten la motivación con esta tesis, la provisión de un lenguaje que permite la descripción de sistemas abiertos en los que no todos los participantes son conocidos proveyendo, entre otras cosas, un mecanismo de composición parcial de componentes.\\

\emph{Interface automata} \cite{dealfaro:esec-fse-01}: es un lenguaje basado en autómatas que captura el comportamiento asumido respecto al orden en el que los métodos de una componente son invocados, y el orden en el que se invocan métodos externos. Similar a las CFSMs esto permite modelar la interacción entre distintas componentes de un sistema. Al igual que los AFCAs estos autómatas modelan no solo comportamiento de la comunicación (a través de acciones de input y output) sino también internas, y pueden componerse dadas ciertas condiciones de compatibilidad. La desventaja respecto a los AFCAs es que las interacciones entre estos autómatas tienen semántica sincrónica, lo que se hace explícito en la composición de dos autómatas donde una acción de salida de un autómata que coincide con la de entrada de otro se transforman en una única acción.\\

\emph{Global Types for Open Systems} \cite{barbanera:eptcs279}: son formalismos basados en Global Types permiten describir el comportamiento general de un sistema distribuido y al mismo tiempo formalizar ciertas propiedades de seguridad para la comunicación entre las componentes del sistema. La visión centralizada de los \emph{global types} es adecuada para describir sistemas cerrados, es decir, sistemas en los que todas las componentes que forman parte de él son conocidas. Esto impide que un sistema descrito en base a \emph{global types} se pueda ver como un módulo independiente que puede conectarse a otros sistemas. De la necesidad de resolver esta problemática surgen los \emph{global types abiertos}. En este enfoque un \emph{global type abierto}, denominado \emph{global type with interface roles} (GTIR), denota un número de sistemas abiertos de CFSMs donde ciertos participantes (roles en este contexto) son identificados como interfaces en vez de como participantes propiamente dichos. Para lo cual se introduce una sintaxis paramétrica que, dado un formalismo basado en \emph{global types}, extiende su sintaxis, permitiéndole identificar algunos roles como \emph{interface roles} y definir una composición de \emph{global types abiertos}, interpretados semánticamente como sistemas de CFSMs. Esta sintaxis no depende de un formalismo particular, sino en general mientras las componentes individuales o \emph{end points} puedan ser interpretados como CFSMs. Esta nueva sintaxis además permite asegurar la preservación de las condiciones de seguridad mencionadas anteriormente bajo la composición, siempre que se satisfagan ciertas condiciones. Similar a otros de los modelos presentados, los GTIRs presetan una visión global de la comunicación donde lo que se conectan son CSs. A diferencia de los Interface Automata, sólo se enfoca en la comunicación y, dado el nivel de abstracción, no modela comportamiento interno de los componentes. Por último los GTIRs son un modelo basado en Global Types mientras que el nuestro en la sintaxis y semántica de autómatas finitos. \\

\emph{Choreography automata} \cite{barbanera:coordination20}: De la tendencia de modelar microservicios y sistemas distribuidos como coreografías, y los autómatas como modelo de especificación ya establecido y sustentado por múltiples resultados, surgen los \emph{Choreography Automata}. Estos autómatas finitos, que pueden ser sincrónicos o asincrónicos, modelan coreografías de communicating systems. La proyección de un choreography automata produce un CS del que se pueden extraer sus componentes en forma de CFSMs. A diferencia de los AFCAs, que modelan componentes desde una visión local, con la posibilidad de escalar a través de la composición,  estos autómatas presentan un enfoque global. Es un lenguaje de más alto nivel que especifica la comunicación desde un punto más abstracto pero que a través de proyecciones se llega a más específico como CSs, de los que a su vez pueden obtener CFSMs. La otra discrepancia con nuestro trabajo es que los choreography automata se abstraen de modelar canales o buffers explícitos y solo ven el comportamiento comunicaconal, no especifican cómputo interno de los componentes.

\section{Trabajo futuro}
Si bien el lenguaje soporta binding parcial, queda por estudiar en mayor profundidad si el lenguaje cumple con las condiciones esperadas. Para esto es necesario definir formalmente la composición parcial de AFCAs y ver la relación entre un AFCA obtenido por una serie de composiciones parciales y uno de una composición total. Esto permite vincular los crterios de corrección de la comunicación establecidos por el lenguaje formal de las CFSM con el comportamiento del resultado de la composición dinámica del sistema. \\
Una condición que se pide en este modelo es que el conjunto de autómatas y el autómata compuesto sean weak determinate. Esta condición es muy fuerte y restrictiva dado que la propiedad de weak determinacy no se preserva en la composición. De esta condición surge la pregunta de si es posible lingüísticamente generar autómatas weak determinate que al componerse den uno que también lo sea. Una forma posible de solucionar esto sería un modelo donde el comportamiento interno no esté representado en las aristas del autómata, sino de alguna manera encapsularlo dentro de los estados. De este modo potencialmente se evitaría el problema de que la composición de autómatas weak determinate pueda genera uno que no lo es.


