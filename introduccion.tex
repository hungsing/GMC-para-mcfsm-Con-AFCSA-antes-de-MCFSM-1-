%!TEX root = ./main.tex
\section{Introducción}
La teoría de autómatas es el estudio de artefactos abstractos de computación o ``máquinas''. Antes de la existencia de computadoras, Alan Turing estudió una máquina abstracta que tenía todas las capacidades de las computadoras de hoy, en el aspecto de qué podían computar \cite{turing:plms-s2-42_1,turing:plms-s2-43_1}. \cnote{No me resulta obvio que este fuera tanto un objetivo como una conclusión de los resultados. Sacaste esta frase de algún lado?}El objetivo de Turing era describir con precisión el límite entre lo que una computadora podía hacer y lo que no. \cnote{Discutamos estas dos frases porque hay algo pero hay que ser cuidadoso.}Estas conclusiones no aplican a sus máquinas abstractas sino a las máquinas reales de hoy en día.

Entre los 40s y los 50s se estudiaron máquinas más sencillas, que hoy denominamos 'autómatas finitos'. Estos autómatas, originalmente pensados para modelar el funcionamiento del cebebro, resultaron ser muy útiles para una variedad de propósitos. Noam Chomsky inició el estudio de gramáticas formales \cite{chomsky:iretit-2_3}. Si bien no eran estrictamente máquinas, estas gramáticas tienen una realción muy cercana con los autómatas abstractos y hoy en día sirven como la base de algunos componentes de software importantes, incluyendo partes de compiladores.

Todos estos desarrollos teóricos tienen relación directa con lo que se estudia en ciencias de la computación. Algunos de estos conceptos, como autómatas finitos y ciertas gramáticas formales, se usan en el diseño y la construcción de distintos tipos de artefactos de software.

Los autómatas consisten de estados (representados gráficamente con círculos) y transiciones (representadas con flechas). Cuando el autómata ve el símbolo de entrada, ejecuta la transición a otro estado, de acuerdo con su función de transición que toma el estado actual y el símbolo reciente como parámetros de entrada. Un autómata finito puede tener uno o más estados finales o \emph{accepting states}. Estos estados representan el fin de la ejecución del proceso modelado por el autómata.

La tendencia hacia los sistemas distribuidos genera la necesidad de mecanismos de comunicación más complejos. Para manejar esta complejidad se han introducido lenguajes de especificación y métodos formales de análisis que permiten asegurar ciertas propiedades de dichos mecanismos como por ejemplo, las \emph{Communicating Finite State Machines} \cite{CFSM}, los \emph{Global Graphs} \cite{castagna:lmcs-8_1}, los \emph{Session types} en su gran diversidad de variantes \cite{honda:esop98,honda:popl08} y los \emph{Interface automata} \cite{dealfaro:esec-fse-01}. Tomando esto en consideración, los autómatas finitos resultan útiles como lenguaje primitivo de modelado, subyacente en muchos de los formalismos mencionados anteriormente, que permite representar algunos de estos aspectos de dichos sistemas.

Service oriented computing (SOC) es un paradigma de computación distribuida que cambió el modo en que los sistemas de software son concebidos. El corazón del paradigma son servicios que proveen elementos computacionales autónomos, independientes de la plataforma y que ejecutan sobre una infraestructura de cómputo y comunicación existen. Estos pueden ser descritos, publicados, descubiertos y programados usando protocolos estándar para construir redes de aplicaciones que colaboran entre sí, incluso distribuidas dentro de distintas fronteras organizacionales, con el objetivo de alcanzar un objetivo de negocios.

\cnote{Falta un párrafo que especifique un poco más cuál es la contribución de la tesis en este terreno.}

\cnote{Falta un párrafo diciendo cómo está organizado el trabajo.}