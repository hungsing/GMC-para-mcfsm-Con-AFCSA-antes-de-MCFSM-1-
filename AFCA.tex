%!TEX root = ./main.tex


\section{Componentes Asincrónicas}


\subsection{Autómatas finitos de comunicación asincrónica}
Las CFSMs son un tipo de autómata que modela únicamente la comunicación externa con otros participantes del sistema. Necesitábamos un tipo de autómata que además representara otro además comportamientos internos. Para esto primero recurrimos a los Input Output Atomata (Ref IO). 
Un I/O automaton modela un componente de un sistema distribuido que puede interactuar con otros sistemas componentes. Es un tipo de máquina de estados en la cual las transiciones están asociadas con determinadas acciones específicas. Existen tres tipos de acciones: input, output, y acciones internas. El autómata usa sus acciones de input y output para comunicarse con el enotrno, mientras que las acciones internas son sólo visibles para el autómata. A diferencia de las acciones internas y las de output que son seleccionadas y resueltas por el autómata, las de entrada, que llegan del entorno, no están bajo control del autómata. Para componer estos autómatas se requiere que sincronicen las acciones compartidas. Es decir cuando un autómata ejecuta una transición con la etiqueta $\pi$, todo autómata que tenga esa acción $\pi$ la ejecuta en simultáneo.
El problema es que los IO no representan bien la comunicación asincrónica. Las operaciones de comunicación externa sincronizan a todos los participantes del sistema. Es decir que si dos autómatas componentes tienen una misma transición, se ejecutan en simultáneo. Esto va en contra de la idea de asincronsidad que buscamos.

\begin{definition}[Cola]
\label{def:cola}
Una cola es un tipo de estructura de datos caracterizada por ser una secuencia de elementos first in-first out (FIFO) debido a que el primer elemento en entrar es el primer elemento en salir. Para manejarla se definen dos operaciones, una para agregar y otra para sacar elementos de la una cola. Para los usos de este trabajo vamos a definir colas en las cuales se depositan y de las cuales se retiran mensajes, con las operaciones:

\begin{itemize}
\item Cola vacía: denotado $[\ ]$
\item Encolar mensaje: denotado como $b \ll m$, si $b$ es una cola y $m$ es un mensaje.
\item Desencolar mensaje: denotado como $b \gg m$, si $b$ es una cola y $m$ es un mensaje.
\item Sea una cola vacía $b= [\ ]$ al aplicarle la operación $b \ll m$ queda $b= [m]$
\item Sea una cola no vacía $b= [m_1,..,m_n]$ al aplicarle la operación $b \ll m$ queda $b= [m,m_1,..,m_n]$ del mismo modo al aplicarle $b \gg m_n$ queda $b= [m,m_1,..]$
\end{itemize}
\end{definition}

\begin{definition}[Autómata finitos de comunicación asincrónica]
\label{def:afca}
Sea $\mathcal{P}$ un conjunto de participantes y $\mathcal{M}$ un conjunto de mensajes. Un \emph{autómata finitos de comunicación asíncrona} es una estructura $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$ tal que:

\begin{itemize}
\item $Q$ es un conjunto finito de estados,
\item $B \subseteq \{pq_n \ | \ pq \in \mathcal{P}^2, n \in \mathbb{N}, p \neq q \} $ es un conjunto finito de buffers (i.e. colas, ver Def.~\ref{def:cola}),
\item $\mathcal{C} \subseteq \{pq_n \ | \ pq \in \mathcal{P}^2, n \in \mathbb{N}, p \neq q \}$ es un conjunto de canales tales que $B \cap \mathcal{C} = \emptyset$ 
\item $\Sigma = \{ \Sigma_\mathit{Int} \cup \Sigma_\mathit{Ex} \cup \Sigma_\mathit{Buff}\} $, $\Sigma \cap \mathcal{M} = \emptyset$ es el conjunto de etiquetas del autómata, siendo
\begin{inparaenum}[1)]

\item $\Sigma_\mathit{Int}$ las acciones internas del autómata 

\item $\Sigma_\mathit{Ex}$ un conjunto de etiquetas de la forma $\mathit{In}(c,m), \mathit{Out}(c,m)$ dónde $c \in \mathcal{C}$ es el canal a través del cual se resuelve la misma y $m \in \mathcal{M}$ es el mensaje .

\item $\Sigma_\mathit{Buff}$ es el conjunto de etiquetas de las acciones sobre los buffers de la forma $b \ll m$ o $b \gg m$, dónde $b \in B$ y $m \in \mathcal{M}$.
\end{inparaenum}
\item $\delta = (\delta_\mathit{Int} \cup \delta_\mathit{Ex} \cup \delta_\mathit{Buff})$ siendo:

\begin{inparaenum}[1)]
\item $\delta_\mathit{Int} \subseteq Q \times \Sigma_\mathit{Int} \times Q$ es la relación de transicion por acciones internas de $A_\mathcal{P}$, %transiciones internas

\item $\delta_\mathit{Ex} \subseteq Q \times \Sigma_\mathit{EX}  \times Q$ es la relación de transición de comunicación externa de $A_\mathcal{P}$, %comunicación externa

\item $\delta_\mathit{Buff} \subseteq Q \times \Sigma_\mathit{Buff} \times Q$ %comunicación interna
\end{inparaenum}
\item $q_0 \in Q$ es el estado inicial, y
\item $F \subseteq Q$ es el conjunto de estados finales. 
\end{itemize}

Se denota $P(A)$, al conjunto de participantes que integran el autómata A, y se define como $P(A) = \left(p \in \mathcal{P} \ | \left(\exists\ \langle p1,p2,c\rangle \in \Sigma_\mathit{Ex}\right)\left(p1=p \lor p2=p\right) \right) $ 
\end{definition}

$\Sigma$ es el conjunto de todas las etiquetas del autómata y lo dividimos en tres subconjuntos disjuntos que la forman $\Sigma_{\mathit{Int}}$, $\Sigma_{\mathit{Ex}}$ y $\Sigma_{\mathit{Buff}}$ que corresponden a las acciones de procesamiento interno, las de comunicación externa con otros participantes y las de comunicación interna vía buffers.

$\Sigma_{Ex}$ es el conjunto de etiquetas correspondientes a la comunicación externa del autómata. Como la comunicación es dirigida punto a punto, cada etiqueta incluye a dos participantes $p_1, P_2 \in \mathcal{P}$ (emisor y receptor) y un canal $c \in \mathcal{C}$. Necesariamente en todas las etiquetas vale que $p_1$ y $p_2$ son distintos y .

$\Sigma_{Buff}$ es el conjunto de etiquetas de acciones de comunicación interna vía buffers. Se especifican las acciones de encolar y desencolar como $b \ll m$, $b \gg m$, respectivamente, donde $b \in B$ y $m$ es el mensaje que se inserta/extrae del mismo.

$\delta$ es el conjunto de transciciones que se compone de $\delta_{Int}$, las acciones internas, $\delta_{Ex}$ las transiciones de comunicación con otros agentes y $\delta_{Buf}$ las acciones de buffer.

$\delta_{Ex}$ se compone de dos tipos de acciones denotadas \textit{In(c,m)} y \textit{Out(c,m)}, con $c \in \Sigma_{Ex}$ y $m \in \mathcal{M}$ . Las acciones de entrada o input que representan la recepción de un mensaje de algún proceso externo al correspondiente al autómata,  y las acciones de output o salida que representan el envío de un mensaje y se denotan. Estas acciones son la parte externa de la comunicaión asincrónica. Como los canales son unidireccionales decimos que para todo par de participantes existen dos canales, uno por cada sentido.

$\delta_{Buff}$ es la relación de transición de comunicación interna mediante buffers.\\

Formalmente, F $\subseteq$ Q. Es el conjunto de estados finales, los posibles estados a los que una ejecución llega y es aceptada como válida. Para los autómatas asincrónicos pedimos también que al llegar a este estado final los buffers se encuentren vacíos. Para esto definimos lo siguiente:

\begin{definition}[Configuración instantánea]
Dados $\mathcal{P}$ un conjunto de participantes y $\mathcal{M}$ un conjunto de mensajes. A un autómata con comunicación asincrónica $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$, definimos:

Una configuración instantánea del autómata como $\langle q, \Omega \rangle \in Q \times \{ [m_b]_{b \in B} | m_b \in \mathcal{M}^* \}$ donde $\mathcal{M}^* = \{ [s_o, \ldots, s_n] \  | \ \forall i \in [0, \ldots, n], s_i \in \mathcal{M} \}$ y $[m_b]_{b \in B} $

\begin{itemize}
\item  q es es el estado actual
\item $\Omega$ es el conjunto de buffers (con sus respectivos contenidos hasta el momento). Decimos que $\Omega$ es de la forma ${ \omega_{b_1}, \omega_{b_2},..., \omega_{b_n} }$ con $b_i \in B$. 
\item Decimos que una configuración es inicial si $q = q_0$ y $ \Omega = \{ [], \ldots, [] \}$
\item Decimos que una configuración es final si $q \in F$ y $ \Omega = \{ [], \ldots, [] \}$
\end{itemize}
\end{definition}

\begin{definition}[Relación de transición entre configuraciones]
\label{def:reltransAFCA}
Sean $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$, $q_1, q_2 \in Q$, $ m \in \mathcal{M}$ definimos $\vdash$, relación de transición entre configuraciones, como:  
\begin{enumerate}
\item $\langle q_1, \Omega \rangle \vdash \langle q_2, \Omega \rangle \iff \langle q_1,r, q_2 \rangle \in \delta \land r \in \Sigma \setminus \Sigma_\mathit{Buff}$

\item $\langle q_1 ,\{\omega_{b_1},\ldots,\omega_{b_i},\ldots,\omega_{b_n}\} \rangle \vdash \langle q_2,\{\omega_{b_1},\ldots,m : \omega_{b_i},\ldots,b_n\}\rangle \iff \langle q_1, b_i \ll m, q_2 \rangle  \in \delta $ 

\item $\langle q_1, \{\omega_{b_1},\ldots,\omega_{b_i} : m,\ldots,\omega_{b_n}\} \rangle \vdash \langle q_2, \{\omega_{b_1},\ldots,\omega_{b_i},\ldots,\omega_{b_n} \}\rangle \iff \langle q_1, b_i \gg m, q_2 \rangle \in \delta$
\end{enumerate}

\end{definition}

% \begin{definition}[Estados y configuraciones alcanzables]
% \label{def:estadosyconAFCA}
%   Una configuración $c' = \langle q', \Omega' \rangle$ es \emph{alcanzable} desde otra  configuración $c = \langle q, \Omega \rangle$ a través de la \emph{ejecución de la transición} $l$ (escrito $c \overset{l}{\rightarrow} c'$) si existe un $m \in \mathcal{M}$ tal que ocurre una de las siguientes alternativas:
% 	\begin{enumerate}
% 		\item $l = b_i \ll m$, $\langle q, l,  q'\rangle \in \delta$, $\Omega = [\omega_{b_1},\ldots, \omega_{b_i},\ldots,b_n]$ y $\Omega' = [\omega_{b_1},\ldots,m : \omega_{b_i},\ldots,b_n]$
% 		\item $l = b_i \gg m$, $\langle q, l,  q'\rangle \in \delta$, $\Omega = [\omega_{b_1},\ldots,m : \omega_{b_i},\ldots,b_n]$ y $\Omega' = [\omega_{b_1},\ldots, \omega_{b_i},\ldots,b_n]$
% 	\end{enumerate}
% La clausura reflexoEscribimos $ s_1 \overset{t1...tm}{\rightarrow} s_{m+1}$ cuando para algún $s_2,...,s_m, s_1\overset{t}{\rightarrow} s_2...s_m\overset{t_m}{\rightarrow} s_{m+1} $ . El conjunto de configuraciones alcanzables de S es $RS(S) = \{s | s_0 \rightarrow^*S \}$
% \end{definition}

\begin{definition}[Traza de un AFCA] Llamamos traza a una secuencia posible de acciones de un autómata. Se define como una secuencia finita de etiquetas de estado y transición altenradas, que comienza y termina con un estado. Dado un autómata $A_\mathcal{P} = \langle Q, B, \mathcal{C}, \Sigma, \delta, q_0, F\rangle$, una traza tiene las siguientes caracterísitcas

\begin{itemize}
\item Tiene la forma $[q_0, \sigma_1, q_1,...,q_{n-1}, \sigma_n, q_n] $ donde 
\item $q_0$ es el estado inicial del autómata
\item $q_i \in Q$,
\item $ \sigma_i \in \Sigma$ y
\item $\langle q_{i-1}, \sigma_i, q_i \rangle \in \delta $ 
\end{itemize}

El comportamiento de un AFCA es el conjunto de todas las trazas posibles.
\end{definition}




% \begin{definition}[Condición de aceptación] Sea $\sigma$ una secuencia de transiciones sobre $A_{\mathcal{P}}$, decimos que es una ejecución válida si se cumple lo siguiente:

% \centering
% $\sigma \in E(A_{\mathcal{P}}) \iff \exists q_f \in F \ | \  (q_0, \sigma, [[],..,[]]) \vdash^*(q_f, \emptyset, [ [],..,[] ])$ 
% \end{definition}


% Entonces decimos que una ejecución aceptable es aquella que cumple que en una cantidad finita de pasos llegó a un estado final con los buffers vacíos, asegurándonos la ausencia de mensajes huérfanos y deadlocks.


\begin{definition}[Ejecución de un AFCA]. Una ejecución es un $ \tau = \tau_0, \ldots,\tau_n $ donde $\tau_0$ es la configuración inicial, $\langle \tau_i, \tau_{i+1} \rangle \in \vdash$, $\tau_n$ es una configuración final y $ \forall i \in [1, \ldots, n], \tau_i$ es una configuración válida. Una ejecución es una configuración que no entra en deadlock, mensajes huérfanos ni receptor no especificado.
\end{definition}

\begin{example}[Ejemplo de un Autómata Finito de Comunicación Asincrónica]
\label{ex:AFCA}
Considere el AFCA $S= \langle \{q_0,..,q_5\},[b_0],\{sr_1,sr_2,rs_1\}, \Sigma_A, \delta_A, q_0, \{q_4\} \rangle$. Donde $\Sigma =\{wait, b_0 \ll m_1,b_0 \gg m_1, Out(sr_1,a),Out(sr_2,c), In(rs_1,b),In(rs_2,d) \}$
\begin{center}
\begin{tikzpicture}[->, thick]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [right= 1.5cm of q_0 ] {$q_1$};
 \node[state] (q_5) [right= 1.8cm of q_1 ] {$q_5$};
 \node[state] (q_2) [below= of q_0 ] {$q_2$};
 \node[state] (q_3) [right= 1.5cm of q_2 ] {$q_3$};
 \node[state,accepting] (q_4) [right= 1.8cm of q_3 ] {$q_4$};
 \draw[]        
        (q_0) edge[above] node{$b_0 \ll m_1$} (q_1)
        (q_0) edge[left] node{$Out(sr_1,a)$} (q_2)
        (q_1) edge[above] node{$Out(sr_2,c)$} (q_5)
        (q_2) edge[above] node{$In(rs_1,b)$} (q_3)
        (q_2) edge[bend right, below] node{$wait$} (q_4)
        (q_3) edge[above] node{$In(rs_2,d)$} (q_4)
        (q_5) edge[right] node{$b_0 \gg m_1$} (q_4)
        ;
\end{tikzpicture}
\end{center}
En el ejemplo podemos ver los tres tipos de transiciones que los AFCA pueden realizar. 

\begin{itemize}
    \item Transiciones de buffer interno: $b_0 \ll m_1$ y $b_0 \gg m_1$
    \item Transiciones de comunicación externa: $Out(sr_1,a),Out(sr_2,c), In(rs_1,b)$ y $In(rs_2,d) $
    \item Transiciones internas: $wait$
\end{itemize}
\end{example}

Como la idea es que los autómatas con comunicación asincrónica representen procesos, o servicios, que pueden formar parte de un sistema más grande, necesitamos definir la operación de composición. Para que un par de autómatas $E$ y $R$ sean plausibles de ser compuestos se deben satisfacer las siguientes condiciones:
 \begin{enumerate}
\item $\Sigma_{E Int} \cap \Sigma_{R Int} = \emptyset$ el conjunto de etiquetas internas debe ser disjunto. 
\item $ B_E \cap B_R = \emptyset$ el conjunto de Buffers de ambos autómatas debe ser disjunto  
\end{enumerate}
\begin{definition}[Composición]\label{def:comp}
\label{composicion}
Dados $\mathcal{P}$ un conjunto de participantes y $\mathcal{M}$ un conjunto de mensajes. Denominamos al conjunto de autómatas participantes como $E_\mathcal{P} = \{E_{p_i} \ | p_i \in \mathcal{P}\}$, dónde $E_{p_i}= \langle Q_{p_i}, B_{p_i}, \mathcal{C}_{p_i}. \Sigma_{p_i}, \delta_{p_i}, q_{0{p_i}}, F_{p_i} \rangle$. Dado un conjunto de autómatas se exige que todo par de integrantes sean compatibles (i.e. se satisface que para todos $p_i, p_j \in \mathcal{P}$, $\Sigma_{p_i} \cap \Sigma_{p_j}= \emptyset$ y $B_{p_i} \cap B_{p_j} = \emptyset$). Luego, definimos la composición $E_\mathcal{P} = ||_{1..n} E_{p_i}$ como sigue:
\begin{itemize}
    \item $Q_\mathcal{P}= \Pi_{p_i \in \mathcal{P}} Q_{p_i}$ (i.e. el conjunto de estados de la composición es el producto cartesiano de los estados de los autómatas componentes),    
    \item $B_\mathcal{P} = \bigcup_{p_i \in \mathcal{P}} B_{p_i} \cup \{ \omega_c \ | \ \mbox{there exists } p_i, p_j \in \mathcal{P} \mbox{ such that } c \in \mathcal{C}_{p_i} \cap \mathcal{C}_{p_j} \}$ (i.e. el conjunto de nombres de buffers del autómata resultante se compone de los buffers de cada autómata participante en la composición, junto con uno nuevo por cada canal compartido entre cada par de autómatas, dichos canales son aquellos mediante los cuales los autómatas a componer intercambian mensajes),    
    \item $\mathcal{C}_\mathcal{P} = \bigcup_{p_i \in \mathcal{P}} \mathcal{C}_{p_i} \setminus \{ c_k \ | \mbox{for all } p_i, p_j \in \mathcal{P}, c \in \mathcal{C}_{p_i} \cap \mathcal{C}_{p_j} \}$,    
    \item $\Sigma_\mathcal{P} = \Sigma_{\mathcal{P}\mathit{Int}} \cup  \Sigma_{\mathcal{P}\mathit{Ex}} \cup \Sigma_{\mathcal{P}\mathit{Buff}}$ tal que:    
    \begin{inparaenum}[1)]
        \item $\Sigma_{\mathcal{P}\mathit{Int}} = \bigcup_{p_i \in \mathcal{P}} \Sigma_{p_i\mathit{Int}}$,
        \item $\Sigma_{\mathcal{P}\mathit{Ex}} = \bigcup_{p_i \in \mathcal{P}} \Sigma_{p_i\mathit{Ex}} \setminus \Sigma_{p_i \mapsto p_j}$ y 
        \item $\Sigma_{\mathcal{P}\mathit{Buff}} = \bigcup_{p_i \in \mathcal{P}} \Sigma_{p_i\mathit{Buff}} \cup \Sigma_{p_i \mapsto p_j}$,
    \end{inparaenum}
donde $\Sigma_\mathit{p_i \mapsto p_j} =\{ \langle p_i,p_j,c \rangle \ | \ p_i, p_j \in \mathcal{P}, \  c \in \mathcal{C}_{p_i} \cap \mathcal{C}_{p_j}\}$
\item $\delta_{\mathcal{P}} = \delta_{\mathcal{P}\mathit{Int}} \cup \delta_{\mathcal{P}\mathit{Ex}} \cup \delta_{\mathcal{P}\mathit{Buff}}$ tal que:
\begin{enumerate}
\item $\delta_{\mathcal{P}\mathit{Int}} \subseteq Q_{\mathcal{P}} \times \Sigma_{\mathcal{P} Int} \times Q_{\mathcal{P}}$  es la relación de transición interna, tal que que se satisface la siguiente fórmula:
$$(\forall \langle q, \sigma, q' \rangle \in \delta_{\mathcal{P}\mathit{Int}})(\exists p_i \in \mathcal{P})(\exists q_{p_i}, q'_{p_i} \in Q_{p_i}, \sigma \in \Sigma_{p_i})(\langle q_{p_i}, \sigma, q'_{p_i} \rangle \in \delta_{p_i Int})$$

\item $\delta_{\mathcal{P}\mathit{Ex}} \subseteq Q_{\mathcal{P}} \times \Sigma_{\mathcal{P}\mathit{Ex}} \times Q_{\mathcal{P}}$ es la relación de transición externa, tal que que se satisface la siguiente fórmula: $$(\forall \langle q, \sigma, q' \rangle \in \delta_{\mathcal{P}\mathit{Ex}}) (\exists p_i \in \mathcal{P})(\exists q_{p_i},q'_{p_i} \in Q_{p_i}, \sigma \in \Sigma_{p_i}) (\langle q_{p_i},\sigma,q'_{p_i} \rangle \in \delta_{p_i Ex})$$

\item $\delta_{\mathcal{P}\mathit{Buff}} \subseteq Q_{\mathcal{P}} \times \Sigma_{\mathcal{P} \mathit{Buff}} \times Q_{\mathcal{P}}$ es la relación de transición por comunicación asincrónica interna tal que se satisface la siguiente fórmula:
$$
\begin{array}{l}
\langle q, \sigma, q' \rangle \in \delta_{\mathcal{P}\mathit{Buff}} \mbox{ sii } (q = \langle q_k \rangle_{p_k \in \mathcal{P}} \land q' = \langle q'_{k'} \rangle_{p_{k'} \in \mathcal{P}} \land\\
\qquad
\begin{array}{l}
((\exists p_i \in \mathcal{P})((\forall p_k \in \mathcal{P})(p_k \neq p_i \implies q_k = q'_k) \land \\
\qquad(\exists \omega_b \in B_{p_i}, \omega_b \{\gg, \ll\} m \in \Sigma_{{p_i} \mathit{Buff}})(\langle q_i, \omega_b \{\gg, \ll\} m, q'_i \rangle \in \delta_{p_i \mathit{Buff}}) \land\\
\qquad\qquad \sigma = \omega_b \{\gg, \ll\} m)\lor\\
(\exists p_i, p_j \in \mathcal{P})(p_i \neq p_j \land (\forall p_k \in \mathcal{P})((p_k \neq p_i \land p_k \neq p_j) \implies q_k = q'_k) \land \\ 
\qquad ((\exists \mathit{Out}(c_{{p_i, p_j}_n}, m) \in \Sigma_{{p_i} \mathit{Ex}})(\langle q_i, \mathit{Out}(c_{{p_i, p_j}_n}, m), q'_i \rangle \in \delta_{p_i  \mathit{Ex}} \land\\
\qquad\qquad \sigma = \omega_{c_{{p_i p_j}_n}} \ll m) \lor \\ 
\qquad (\exists \mathit{In}(c_{p_j,{p_i}_n}, m) \in \Sigma_{{p_i} \mathit{Ex}})(\langle q_i, \mathit{In}(c_{p_j,{p_i}_n}, m), q'_i \rangle \in \delta_{p_i \mathit{Ex}} \land\\
\qquad\qquad \sigma = \omega_{c_{p_j,{p_i}_n}} \gg m))))
\end{array}
\end{array}
 $$
 
Además vale que $\forall q_i,q_j \in Q_\mathit{\mathcal{P}}, \ m \in \mathcal{M} \ |	 \ \langle q_i, [\omega_\mathit{b}]_{b \in B_\mathcal{P}} \gg m, q_j \rangle$

$\langle q_i, [\omega_\mathit{b}]_{b \in B_\mathcal{P}} \gg m, q_j \rangle \in \delta_\mathit{\mathcal{P}Buff} \iff \exists q'_i, q'_j \in Q_\mathit{\mathcal{P}}$ tal que $\ \langle q'_i, [\omega_\mathit{b}]_{b \in B_\mathcal{P}} \ll m, q'_j \rangle \in \delta_\mathit{\mathcal{P}Buff}$ y se cumple una de las siguientes condiciones:
\begin{enumerate}
\item $q'_j = q_i$ 
\item $\exists \sigma \in \Sigma_\mathit{\mathcal{P}}$ tal que $\langle q'_j, \sigma, q_i \rangle \in \delta_\mathit{\mathcal{P}} \land \sigma \neq [\omega_\mathit{b}]_{b \in B_\mathcal{P}} \gg m $
\item $\exists s=[q'_j,...,q_i] $ donde s es una secuencia finita de estados tales que $s[0]= q'_j, s[n-1]=q_i$ y sea $ 0 \ll x \ll$ n-1,$s[x] \in Q_\mathit{\mathcal{P}}$ y $\forall s[x], s[x+1], \exists \sigma \in \Sigma_\mathit{\mathcal{P}} \land \langle s[x], \sigma, s[x+1] \rangle \in \delta_\mathit{\mathcal{P}} $  
\end{enumerate} 
\end{enumerate}
\item $q_0 = \langle {q_0}_{p_1}, \ldots, {q_0}_{p_n} \rangle$, y
\item $F_{\mathcal{P}} = \bigcup_{1..n} F_{p_i}$.
\end{itemize}
\end{definition}


Cada autómata es un sistema independiente que cumple una función (o una serie de funciones), y se relaciona con otros a través del envío de mensajes. Para asegurarnos esto pedimos que para todo par de autómatas a componerse tengan conjuntos de etiquetas de acciones que sean disjuntos. 

Del mismo modo, cada autómata tiene su propio conjunto de buffers que pedimos sean disjuntos, para distinguir la comunicación interna de cada autómata componente de la que ocurra entre componentes o con participantes externos. Para modelar la comunicación interna entre componentes, agregamos dos buffers por cada par de integrantes, uno para cada sentido de la comunicación, de $E_{p_i}$ a $E_{p_j}$ y viceversa.

Como los conjuntos de acciones son disjuntos podemos decir que las acciones internas, de comunicación externa y de buffer, de cada componente se preservan, siempre y cuando tenga sentido con la composición de estados. Existe un caso particular que ocurre cuando existían envíos de mensaje de un autómata componente a otro. En ese caso dado que ambos ahora son parte un mismo autómata, la comunicación pasa a ser envío de mensajes interno. Para representar este tipo de comunicación es que utilizamos buffers. De este modo el intercambio que antes era $\mathit{In} (c_{p_i, p_{j_n}},m)$ y $\mathit{Out}(c_{p_j, p_{i_n}},m)$ ahora es $\omega_{c_{p_i p_{j_n}}}  \ll m$ y $b_{c_{p_j, p_{i_n}}}  \gg  m$, donde $ \omega_{c_{p_i, p_{j_n}}}, \omega_{c_{p_j, p_{i_n}}} in \mathcal{C}_{\mathcal{P}} $ son los buffers exclusivos del autómata compuesto. 

Al componer autómatas la comunicación que antes era externa y ahora es de buffer puede generar problemas. Puntualmente pueden aparecer transiciones de consumo de un buffer (que antes eran envío de mensajes) donde antes no había. De este modo pueden aparecer secuencias de estados y transiciones donde se consume un mensaje antes de que este sea depositado en el buffer correspondiente. Para esto pedimos que $\delta_\mathit{\mathcal{P}Buff}$ cumpla con una condición especial. Solo pueden haber transiciones de consumo saliendo de un estado si en alguna secuencia de acciones que termina en ese estado, hay transiciones de producción (es decir se encola un mensaje en el buffer).

\begin{figure}
\begin{example}[Composición de Autómatas Finitos de Comunicación Asincrónica]
\label{ex:Composicion}
Considere los siguientes AFCA:
\begin{itemize}
    \item $S= \langle \{q_0,..,q_4\},[b_0],\{sr_1,rs_1\}, \Sigma_S, \delta_S, q_0, \{q_4\} \rangle$, con $\Sigma_S =\{wait, b_0 \ll m_1,b_0 \gg m_1, In(rs_1,b), Out(sr_1,c) \}$
    \item $R=\langle \{q_0,q_1,q_2\},[],\{sr_1,rs_1\}, \Sigma_R, \delta_R, q_0, \{q_4\} \rangle$, con $\Sigma_R = \{Out(rs_1,b), In(sr_1,c)\}$, y su composición
    \item $\RS =\langle Q_{RS}, [b_0, sr_1, rs_1], \Sigma_{RS}, \delta_{RS}, q_{00}, \{q_{42}\} \rangle$, con $\Sigma_{RS} =\{wait, b_0 \ll m_1,b_0 \gg m_1, rs_1 \ll b, rs_1 \gg b, sr_1 \ll c, sr_1 \gg c) \}$
\end{itemize} 

\begin{tikzpicture}[->, thick][scale=0.33]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [right= 1.5cm of q_0 ] {$q_1$};
 \node[state] (q_2) [right = 1.5 of q_1 ] {$q_2$};
 \node[state] (q_3) [below=  of q_1 ] {$q_3$};
 \node[state,accepting] (q_4) [left= 2cm of q_3 ] {$q_4$};
 \draw[]        
        (q_0) edge[above] node{$In(rs_1,b)$} (q_1)
        (q_1) edge[above] node{$b_0 \ll m_1$} (q_2)
        (q_1) edge[left] node{$wait$} (q_3)
        (q_2) edge[right] node{$\ b_0 \gg m_1$} (q_3)
        (q_3) edge[above] node{$Out(sr_1,c)$} (q_4)
        ;
\end{tikzpicture}
%\caption{S}
\ 
\begin{tikzpicture}[->, thick][scale=0.33]
 \node[state,initial] (q_0)   {$q_0$}; 
 \node[state] (q_1) [below= of q_0 ] {$q_1$};
  \node[state,accepting] (q_2) [below= of q_1] {$q_2$};
 \draw[]        
        (q_0) edge[right] node{$Out(rs_1,b)$} (q_1)
        (q_1) edge[right] node{$In(sr_1,c)$} (q_2)
        ;
\end{tikzpicture} 
\\
\begin{tikzpicture}[->, thick][scale=0.33]
 \node[state,initial] (q_00)   {$q_{00}$}; 
  \node[state] (q_01) [right= 1.8cm of q_00 ] {$q_{01}$};
  \node[state] (q_11) [right= 1.8cm of q_01 ] {$q_{11}$};
  \node[state] (q_21) [right= 1.8cm of q_11 ] {$q_{21}$};
  \node[state] (q_31) [below= of q_21 ] {$q_{31}$};
  \node[state] (q_41) [left= 1.8cm of q_31 ] {$q_{41}$};
  \node[state,accepting] (q_42) [left= 1.8cm of q_41] {$q_{42}$};
  \draw[]        
         (q_00) edge[above] node{$rs_1 \ll b$} (q_01)
         (q_01) edge[above] node{$rs_1 \gg b$} (q_11)
         (q_11) edge[above] node{$b_0 \ll m$} (q_21)
         (q_11) edge[right] node{$wait$} (q_31)
         (q_21) edge[right] node{$b_0 \gg m$} (q_31)
         (q_31) edge[above] node{$sr \ll c$} (q_41)
         (q_41) edge[above] node{$sr \gg c$} (q_42)
       ;
\end{tikzpicture}
\end{example}
\caption{Ejemplo de composición autómata asincrónico de comunicación}
\label{fig:ejemplo-comp}
\end{figure} 
\newpage

\subsection{Aspectos comunicacionales de los AFCA}

Una de las desventajas principales de utilizar CFSM como lenguaje de especificación de en Service Oriented Computing es que la naturaleza del binding en SOC choca con el método de establecer si un conjunto de participantes pueden interacturar libres de errores de comunicación. En SOC el descubrimiento y binding de servicios se realiza por demanda, eso significa que a pesar de que se necesiten muchos servicios para resolver una tarea, se obtienen uno por uno según se van necesitando. Por el otro lado las CFSM requieren el conjunto total de participantes de un protocolo para poder determinar si el protocolo puede llevarse a cabo sin errores. La idea de los AFCA es intentar reducir la distancia entre ambas naturalezas. Por lo tanto una de las tareas principales que queremos lograr con AFCAs es obtener, vía una proyección, la inferfaz de comunicación en la forma de una mCFSM.
Al principio de esta sección introdujimos los AFCA para modelar el comportamiento deseado en SOC de binding incremental. Ahora nos queremos enfocar en los aspectos puramente comunicacionales, es decir la interacción entre distintos participantes. Para hacer énfasis en estos aspectos existen las CFSMs, pero los AFCA introducen con la composición la posibilidad de que haya múltiples canales de comunicación entre dos participantes. En esta sección atendemos dicha problemática introduciendo las Multichannel Communicating Finite State Machines \cite[Def. 82]{mCFSM}. Se definen, del mismo modo que una CFSM sobre $\mathcal{M}$ de la siguiente manera.

\begin{definition}[Multichannel Communicating Finite State Machine - mCFSM] Una multichannel communicating finite state machine (mCFSM) sobre $\mathcal{M}$ es una un sistema finito de transición $(Q, \mathcal{C}, q_0, \mathcal{M}, \delta)$ donde
\begin{itemize}
  \item $Q$ es un conjunto finito de estados
  \item $\mathcal{C} = \{ pq_n \mid pq \in \mathcal{P}^2, n \in \mathbb{N}, p \not= q\}$ es un conjunto de canales
  \item $q_0 \in Q$ es el estado inicial;
  \item $\delta \subseteq Q \times (\mathcal{C} \times \{!,?\} \times \mathcal{M}) \times
    Q$ es un conjunto finito de \emph{transiciones}.
  \end{itemize}

Un communicating system es un mapa S que asigna un mCFSM S(p) a cada $p \in \mathcal{P}$. Escribimos $q \in S(p)$ cuando q es un estado de la máquina S(p) y $\tau$ es una transición de S(p).
  
Al igual que antes la semántica de un communicating system se obtiene considerando configuraciones. Estas configuraciones son iguales a las de las CFSM puras con la salvedad que ahora los canales no están restringidos a un único par entre cada par de participantes.

 \end{definition}
 
% * <ivissani@gmail.com> 2018-01-28T13:14:43.225Z:

% De esta manera lo que tenés es una enumeración de canales entre cada par de participantes. Lo único que hay que hacer es ajustar la semántica (las reglas) a esta nueva notación para que sea coherente.
% 
% Notar que la cantidad de canales existentes entre cada par de participantes ahora es infinita (los naturales) PERO la cantidad de ellos que vas a usar siempre va a ser finita porque de acuerdo a la notación que tenemos hay que fijar qué canal se usa en cada envío/recepción de mensaje y, por lo tanto, el hecho de que EXISTAN infinitos canales no afecta a la semántica ni al poder expresivo de las CFSMs
% 


\begin{definition}[Semántica de una mCSFSM]
\label{def:semanticamCFSM}
La configuración de un multichannel communicating system  \cite[Def. 83]{mCFSM} se define en términos de transiciones entre configuraciones como se ve a continuación:

  La configuración de un communicating system S es un par
  $s = \sysconf{q}{w}$ donde
  $\vectorize{q} = \left(q_\p\right)_{\p \in \mathcal{P}}$ donde
  $q_\p \in S(p)$ para cada $p \in \mathcal{P}$ y
  $\vectorize{w} = \left(w_{pq}\right)_{pq \in \C}$ con
  $w_{pq} \in \mathcal{M} $.
  
  Una configuración $s' = \langle \overrightarrow{q'} ; \overrightarrow{w'} \rangle$ es \emph{alcanzable} desde otra
  configuración $s = \langle \overrightarrow{q} ; \overrightarrow{w} \rangle$ a través de la \emph{ejecución de la transición} $l$ (escrito $s \overset{l}{\rightarrow} s'$) si existe un $m \in \mathcal{M}$ tal que ocurre una de las siguientes alternativas:
	\begin{enumerate}
		\item $l = \langle q_s, sr!m,  q'_s\rangle \in \delta_s$ y 
			\begin{enumerate}
				\item $q'_p = q_p$ para todo $\p \neq s$; y
				\item $w'_{sr} = w_{sr} \cdot m$ y  $w'_{pq} = w_{pq}$ para todo $pq \neq sr$; o bien
			\end{enumerate}
		\item $l = \langle q_r, sr?m,  q'_r\rangle \in \delta_r$ y 
			\begin{enumerate}
			\item $q'_{p} = q_{p}$ para todo $p \neq r$; y
				\item $w_{sr} = m \cdot w'_{pq}$ y $w'_{pq} = w_{pq}$ para todo $pq' \neq sr$
			\end{enumerate}
	\end{enumerate}
Escribimos $ s_1 \overset{t1...tm}{\rightarrow} s_{m+1}$ cuando para algún $s_2,...,s_m, s_1\overset{t}{\rightarrow} s_2...s_m\overset{t_m}{\rightarrow} s_{m+1} $ . El conjunto de configuraciones alcanzables de S es $RS(S) = \{s | s_0 \rightarrow^*S \}$
\end{definition}

\begin{prop}[La semántica de una mCFSM es igual a la de transiciones de comunicación interna de un AFCA]
Si comparamos las reglas 2 y 3 de la \ref{def:reltransAFCA} con las reglas 1 y 2 de \ref{def:semanticamCFSM} vemos que hay mucha similitud.
Una transición de comunicación interna de un AFCA tiene la siguiente semántica 
\end{prop}

Multichannel CFSMs  con un único canal para cada par ordenado de participantes son equivalentes a CFSMs puras.

\begin{definition}[Interfaz de comunicación de un AFCA] Es la mCFSM que resulta de aplicarle el siguiente procedimiento a un AFCA.
\begin{enumerate}
    \item Transformamos toda acción interna y de buffer en una transición $\epsilon$. Esto resulta en una autómata no determinístico con transiciones $\epsilon$
    \item Transformamos el autómata no determinístico rsultante del paso anterior en uno determinístico.
\end{enumerate}
\end{definition}

\begin{figure}[ht]
\begin{example}
        \begin{tikzpicture}[->, thick]
            \node[state,initial] (q_0)   {$q_0$}; 
            \node[state] (q_1) [right= 1.8cm of q_0 ] {$q_1$};
            \node[state, accepting] (q_3) [right= 1.5cm of q_1 ] {$q_3$};
            \node[state] (q_5) [right= 1.8cm of q_3 ] {$q_5$};
            \node[state] (q_2) [below= 1.5cm of q_0 ] {$q_2$};
            \node[state] (q_4) [right= 1.8cm of q_2 ] {$q_4$};
        
            \draw[]        
            (q_0) edge[above] node{$out(pr_1,a)$} (q_1)
            (q_1) edge[above] node{$in(rp_2,d)$} (q_3)
            (q_0) edge[left] node{$in(rp_1,b)$} (q_2) 
            (q_2) edge[below] node{$out(pr_2,c)$} (q_4)
            (q_4) edge[left] node{$intr$} (q_3)
            (q_3) edge[bend right] node{$b_1 \ll m_1$} (q_5)
            (q_5) edge[bend right] node{$b_1 \gg m_1$} (q_3)
        ;
        \end{tikzpicture} 

        \begin{tikzpicture}[->, thick]
            \node[state,initial] (q_0)   {$q_0$}; 
            \node[state] (q_1) [right= 1.5cm of q_0 ] {$q_1$};
            \node[state] (q_2) [below= 1.5cm of q_0 ] {$q_2$};
            \node[state] (q_3) [right= 1.5cm of q_2 ] {$q_3$};

            \draw[]        
            (q_0) edge[above] node{$pr_1!a$} (q_1)
            (q_0) edge[right] node{$rp_1?b$} (q_2)
            (q_1) edge[right] node{$rp_2?d$} (q_3)
            (q_2) edge[above] node{$pr_2!c$} (q_3)
        ; 
        \end{tikzpicture}     
    \caption{AFCA y su mCFSM}
    \label{fig:mCFSM}

\end{example}{}
\end{figure}


En la sección 2.3 explicamos como funciona la condición de Generalized Multiparty Compatibility para CFSMs. Necesitamos ver que la misma condición es aplicable a las Multichannel CFSMs, para esto la solución más práctica que se encontró es ver que podemos emular una Multichannel CFSM con una CFSM pura. Mostrando esa equivalencia vemos que si podemos aplicar GMC al emulador, la condición aplica al emulado. Dado que un multichannel communicating system es libre de errores de comunicación si y solo si el sistema emulado también lo es. El procedimiento consiste en generar un nuevo participante para cada canal entre dos otros participantes. Este nuevo participante es un simple repetidor de mensajes de uno de los participantes a otro. De este modo una comunicación multichannel entre un par de participantes es reemplazada por múltiples comunicaciones de un canal con un repetidor en el medio. El aspecto clave de esta emulación es que preserva el orden de los mensajes.

\begin{definition}[Sistema emulado] \cite[Def. 84]{mCFSM} Dado un multichannel communicating system $(M_p)_{p \in \mathcal{P}}$, agrandamos el conjunto $ \mathcal{P}$ agregando un participante adicional por cada canal en el sistema original $\mathcal{P}'=\mathcal{P} \cup \bigcup_{p \in \mathcal{P}} \{p^{pq_n} \ | \ pq_n \in \mathcal{C}_p \} \cup \bigcup_{p \in \mathcal{P}} \{p^{qp_n} \ | \ qp_n \in \mathcal{C}_p \}$. Cada participante nuevo $p^{sr_n} \in \bigcup_{p \in \mathcal{P}} \{p^{pq_n} \ | \ pq_n \in \mathcal{C}_p \} \cup \bigcup_{p \in \mathcal{P}} \{p^{qp_n} \ | \ qp_n \in \mathcal{C}_p \}$ se define con la siguiente mCFSM:
\begin{itemize}
\item $Q_{p^{sr_n}} = \{q_0\} \cup \bigcup_{m \in \mathcal{M}} \{q_m\}$
\item $\mathcal{C}_{p^{sr_n}} = \{sp_n^{sr_n}, p^{sr_n}r_n,  p^{sr_n}s_n, rp_n^{sr_n} \}$
\item $q_{0_{p^{sr_n}}} = q_0 $
\item $ \delta_{p^{sr_n}} = \bigcup_{m \in \mathcal{M}} \{ (q_0,sp_n^{sr_n}?m,q_m),(q_m,p^{sr_n}r_n!m,q_0)  \} $
\end{itemize}
Cada viejo participante $q \in \mathcal{P}$ se reemplaza por un nuevo participante $q'$ donde:
\begin{itemize}
\item $\mathcal{C}_{q'} = \{qp_n^{qr_n} \ | \ qr_n \in \mathcal{C}_{q} \} \cup \{p^{sq_n}q_n \ | \ sq_n \in \mathcal{C}_{q} \}$ 
\item $ \delta_{q'} = \bigcup_{m \in \mathcal{M}} \{ (q, qp_n^{qr_n}!m, q') \ | \ (q, qr_n!m, q') \in \delta_q \} \cup \{q, p^{sq_n}q_n?m,q' \ | \ (q, sq_n?m, q') \in \delta_q \}$

\end{itemize}
\end{definition} 

Queda claro que si bien transformamos cada canal (buffer) en dos canales nuevos, el orden de los mensajes está garantizado como resultado del modo en que $\delta$ está definido para los repetidores. Nótese que los repetidores respetan ese orden porque al consumir un mensaje desde el canal de 'entrada' (el canal que sirve para recibir mensajes del emisor original) la única acción posible del repetidor es mandar el mensaje a través del canal de salida (el canal que sirve para enviar mensajes al receptor original). Como todo canal es FIFO y los repetidores se comportan del mismo modo, el orden entre dentro de cada canal queda garantiado. Por oro lado, no hay garantía respecto al orden de la comunicación entre canales del modelo original. Por lo tanto podemos decir que los repetidores no introducen más concurrencia que la que estaba en el modelo original y debido a eso los dos sistemas, a pesar de no ser bisimilares y no tener las mismas trazas, son equivalentes respecto a la ausencia de deadlock, recepciones no especificadas y mensajes huérfanos. Esta observación es importante porque provee una forma de chequear multichannesl communication systems recurriendo nuevamente al chequeo de GMC del sistema emulado.

\begin{prop} El sistema emulado preserva los errores comunicacionales

\begin{proof} Primero notemos que los repetidores no pueden generar errores de comunicación dado que en el estado inicial pueden recibir el rango completo de mensajes y luego de ocnsumir un mensaje su única acción posible es reenviarlo. Recordemos también que el orden de los mensajes se preserva. Esto significa que si en el sistema original los mensajes $ m $ y $m'$ fueron enviados en ese orden sobre el canal $sr$ en el sistema emulado se envían en el mismo orden sobre el canal $sp^{sr}$ y por lo tanto son enviados en ese mismo orden a través del canal $p^{sr}r$. Entonces se puede mostrar que para cada error de configuración alcanzable en el sistema original, hay una configuración que presenta el mismo error que es alcanzable en el sistema emulado y viceversa.
\begin{itemize}
\item[$\Rightarrow$] Consideremos cualquier configuración de error $e$ alcanzable en el sistema original y consideremos cualquier camino que alcance $e$. Luego reemplacemos toda acción $sr!m$ con la secuencia de acciones $sp^{sr}!m, sp^{sr}?m, p^{sr}r!m$ y cada acción $sr?m$ con $p^{sr}?m$, este nuevo camino está presente en el sistema emulado y alcanza el estado donde las configuraciones de buffer y transiciones permitidas son las mismas para el conjunto de máquinas compartidas (es decir, todas las máquinas de sistema emulado menos los repetidores) y los repetidores están en su estado inicial con buffers vacíos.
\item[$\Leftarrow$] Consideremos cualquier error de configuración $e$ alcanzable en el sistema emulado y ocnsideremos cualquier camino que alcance $e$. Ya establecimos que el error no puede ser culpa de los repetidores dado que siempre pueden progresar. Por lo tanto sin importar el estado de los buffers en $e$ hay una configuración $e'$ que presenta el mismo error de comunicación y donde el estado de los buffers de los repetidores está vacío y están en su estado inicial. Luego consideremos que cualquier camino que alcance $e'$ está formado por secuencias de la forma $sp^{sr}!m,\ldots, sp^{sr}?m, \ldots, p^{sr}r!m$ y $p^{sr}r?m$ (donde los puntos suspensivos denota la posibilidad de interleaving de otras acciones). Entonces alcanza con reemplazar cada secuencia $sp^{sr}!m,\ldots_0, sp^{sr}?m, \ldots_1, p^{sr}r!m$ con la secuencia $\ldots_0,\ldots_1, sr!m$ y cada $p^{sr}r?m$ con $sr?m$ para obtener un camino que existe en el sistma original y aclanza una configuración que tiene sus buffers en el mismo estado con las mismas transiciones permitidas.
\end{itemize}

\end{proof}

\end{prop}
